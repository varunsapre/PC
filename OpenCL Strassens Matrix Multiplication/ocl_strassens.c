#include "stdafx.h"		//auto-generated by Visual Studio
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <CL/cl.h>

#pragma comment(lib, "OpenCL.lib")

#define MEM_SIZE (128)
#define MAX_SOURCE_SIZE (0x100000)
#define CHECK_ERROR(ret) do { if (ret != 0) {fprintf(stderr, "line %d: error return %d\n", __LINE__, ret); exit(1);} } while (0)

/*
	the kernels needed are stored in a char array since ocl needs to store ".cl" file as string
*/
char kernel_sources_array[] =
"__kernel void submat(__global float *a, __global float *b, __global float *result) "
"{ "
"	size_t id = get_global_id(0); "
"	result[id] = a[id] - b[id]; "
"} "
"__kernel void addmat(__global float *a, __global float *b, __global float *result) "
"{ "
"	size_t id = get_global_id(0); "
"	result[id] = a[id] + b[id]; "
"}";

//global initialization
extern int strassen(int size);
cl_kernel kernel_add=NULL; 
cl_kernel kernel_sub=NULL;
cl_context context = NULL;
cl_command_queue command_queue = NULL;
cl_mem membuf_a = NULL;
cl_mem membuf_b = NULL;
cl_mem membuf_result = NULL;

//OpenCL version of adding matrices
void ocl_add_matrices(int size, float **ap, float **bp, float **resultp)
{
	float *a = ap[0];
	float *b = bp[0];
	float *result = resultp[0];
	cl_uint ret;


	size_t gws[] = { size };
	cl_event event;
	cl_event events[2];
	ret = clEnqueueWriteBuffer(command_queue, membuf_a, CL_FALSE, 0,
		size * sizeof(float), a, 0, NULL, &events[0]);
	CHECK_ERROR(ret);
	ret = clEnqueueWriteBuffer(command_queue, membuf_b, CL_FALSE, 0,
		size * sizeof(float), b, 0, NULL, &events[1]);
	CHECK_ERROR(ret);
	ret = clEnqueueNDRangeKernel(command_queue, kernel_add, 1, NULL, gws, NULL, 2, &events, &event);
	CHECK_ERROR(ret);
	ret = clWaitForEvents(1, &event);
	CHECK_ERROR(ret);
	ret = clEnqueueReadBuffer(command_queue, membuf_result, CL_TRUE, 0,
		size * sizeof(float), result, 0, NULL, NULL);
	CHECK_ERROR(ret);

}
//OpenCL version of subtracting matrices
void ocl_sub_matrices(int size, float **ap, float **bp, float **resultp)
{
	float *a = ap[0];
	float *b = bp[0];
	float *result = resultp[0];
	cl_uint ret;

	size_t gws[] = { size };
	cl_event event;
	cl_event events[2];
	ret = clEnqueueWriteBuffer(command_queue, membuf_a, CL_FALSE, 0,
		size * sizeof(float), a, 0, NULL, &events[0]);
	CHECK_ERROR(ret);
	ret = clEnqueueWriteBuffer(command_queue, membuf_b, CL_FALSE, 0,
		size * sizeof(float), b, 0, NULL, &events[1]);
	CHECK_ERROR(ret);
	ret = clEnqueueNDRangeKernel(command_queue, kernel_sub, 1, NULL, gws, NULL, 2, &events, &event);
	CHECK_ERROR(ret);
	ret = clWaitForEvents(1, &event);
	CHECK_ERROR(ret);
	ret = clEnqueueReadBuffer(command_queue, membuf_result, CL_TRUE, 0,
		size * sizeof(float), result, 0, NULL, NULL);
	CHECK_ERROR(ret);
}

int main(int argc, char *argv[])
{
	int probsize = argc > 1 ? atoi(argv[1]) : 128;
	cl_device_id device_id = NULL;
	cl_mem memobj = NULL;
	cl_program program = NULL;
	cl_kernel kernel = NULL;
	cl_platform_id platform_id = NULL;
	cl_uint ret_num_devices;
	cl_uint ret_num_platforms;
	cl_int ret;

	char string[MEM_SIZE];

	size_t num_platforms = 0;
	/* Get Platform and Device Info */
	ret = clGetPlatformIDs(100, NULL, &num_platforms);
	cl_platform_id * platids = malloc(num_platforms * sizeof(cl_platform_id));
	ret = clGetPlatformIDs(num_platforms, platids, NULL);
	for (cl_uint i = 0; i < num_platforms; ++i)
	{
		char st[10240];
		size_t sz;
		ret = clGetPlatformInfo(platids[i], CL_PLATFORM_VENDOR, 10240, st, &sz);
		if (strcmp(st, "NVIDIA Corporation") == 0)
			platform_id = platids[i];
	}
	free(platids);
	if (platform_id == NULL) abort();

	ret = clGetDeviceIDs(platform_id, CL_DEVICE_TYPE_DEFAULT, 1, &device_id, &ret_num_devices);
	CHECK_ERROR(ret);

	/* Create OpenCL context */
	context = clCreateContext(NULL, 1, &device_id, NULL, NULL, &ret);
	CHECK_ERROR(ret);

	/* Create Command Queue */
	command_queue = clCreateCommandQueue(context, device_id, 0, &ret);
	CHECK_ERROR(ret);

	char * src = malloc(10240);
	strcpy(src, kernel_sources_array);
	size_t szsrc = strlen(src);
	program = clCreateProgramWithSource(context, 1, (const char **)&src, &szsrc, &ret);
	CHECK_ERROR(ret);

	/* Build Kernel Program */
	ret = clBuildProgram(program, 1, &device_id, NULL, NULL, NULL);
	if (ret != 0)
	{
		char log[10240];
		clGetProgramBuildInfo(program, device_id, CL_PROGRAM_BUILD_LOG, 10240, log, NULL);
		printf("Log: %s\n", log);
		exit(1);
	}

	CHECK_ERROR(ret);

	/* Create OpenCL Kernel */
	kernel_add = clCreateKernel(program, "addmat", &ret);
	CHECK_ERROR(ret);
	kernel_sub = clCreateKernel(program, "submat", &ret);
	CHECK_ERROR(ret);
	
	/* Create OpenCL Buffers */
	membuf_a = clCreateBuffer(context, CL_MEM_READ_WRITE, 1024 * sizeof(float), NULL, &ret);
	CHECK_ERROR(ret);
	membuf_b = clCreateBuffer(context, CL_MEM_READ_WRITE, 1024 * sizeof(float), NULL, &ret);
	CHECK_ERROR(ret);
	membuf_result = clCreateBuffer(context, CL_MEM_READ_WRITE, 1024 * sizeof(float), NULL, &ret);
	CHECK_ERROR(ret);

	ret = clSetKernelArg(kernel_add, 0, sizeof(cl_mem), (void *)&membuf_a);
	CHECK_ERROR(ret);
	ret = clSetKernelArg(kernel_add, 1, sizeof(cl_mem), (void *)&membuf_b);
	CHECK_ERROR(ret);
	ret = clSetKernelArg(kernel_add, 2, sizeof(cl_mem), (void *)&membuf_result);
	CHECK_ERROR(ret);
	ret = clSetKernelArg(kernel_sub, 0, sizeof(cl_mem), (void *)&membuf_a);
	CHECK_ERROR(ret);
	ret = clSetKernelArg(kernel_sub, 1, sizeof(cl_mem), (void *)&membuf_b);
	CHECK_ERROR(ret);
	ret = clSetKernelArg(kernel_sub, 2, sizeof(cl_mem), (void *)&membuf_result);
	CHECK_ERROR(ret);

	strassen(probsize);

	/* Final clearing and flushing */
	ret = clFlush(command_queue);
	CHECK_ERROR(ret);
	ret = clFinish(command_queue);
	CHECK_ERROR(ret);
	ret = clReleaseKernel(kernel_add);
	CHECK_ERROR(ret);
	ret = clReleaseKernel(kernel_sub);
	CHECK_ERROR(ret);
	ret = clReleaseProgram(program);
	CHECK_ERROR(ret);
	ret = clReleaseMemObject(membuf_a);
	CHECK_ERROR(ret);
	ret = clReleaseMemObject(membuf_b);
	CHECK_ERROR(ret);
	ret = clReleaseMemObject(membuf_result);
	CHECK_ERROR(ret);
	ret = clReleaseCommandQueue(command_queue);
	CHECK_ERROR(ret);
	ret = clReleaseContext(context);
	CHECK_ERROR(ret);
	
	return 0;
}
